\section{General Considerations About the Design of Matching Units}
\label{sec:extending:general_considerations}

A key concept of openISBT is defining workload on interaction patterns, which are sequences of abstract operations. It matches specific service operations to those abstract operations using matching units. When deriving new abstract operations and implementing matching units, there are several requirements for design and implementation. First, the abstract operations should be specific enough in order to design a realistic interaction pattern and therefore make the benchmark relevant in the meaning of \cite[][p. 38]{Bermbach_Cloud_Service_Benchmarking_2017}. The benchmark should also be portable  \cite[][p. 38]{Bermbach_Cloud_Service_Benchmarking_2017}, and the abstract operation should match to a large number of specific services. However, these are conflicting requirements, and trade-offs are crucial \cite[][p. 43-44]{Bermbach_Cloud_Service_Benchmarking_2017}. 
Also, there are different implementation objectives that a matching unit has to conform to. First, the implementation should be correct in the meaning of \cite[][p. 38]{Bermbach_Cloud_Service_Benchmarking_2017}. The abstract operations we derive are theoretical concepts.
However, the matching units are responsible for matching service operations to the right abstract operations at runtime, and poorly implemented matching units can lead to wrong matching, although the abstract operation is well designed. Also, the abstract operation should be portable \cite[][p. 81-82]{Bermbach_Cloud_Service_Benchmarking_2017} by making as few assumptions as possible. For instance, assuming that description tags in OpenAPI documents are written in English or even assuming that OpenAPI documents use description tags would lead to poor portability. Moreover, a matching unit should only consider the machine-readable elements of the API description to ensure portability.