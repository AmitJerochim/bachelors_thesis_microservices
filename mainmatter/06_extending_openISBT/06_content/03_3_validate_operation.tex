\subsection{The VALIDATE Abstract Operation }
In some cases, services should fulfill validation tasks, e.g., validating the correctness of a phone number or a bank account. Validation can be described by a function that accepts any input and returns a true or false. 

However, finding a common pattern for such services is challenging. First, assuming an HTTP request includes data to validate, we still do not clearly know where to find them. For instance, the service operation GET /vouchers/validate\footnote{\url{https://github.com/AmitJerochim/openapi-data/blob/master/oasFiles/0254_bigdish-consumer-app-1.0.8-swagger.json}} expects the data to be in the URI. In contrast, POST /api/Order/validate\footnote{\url{https://github.com/AmitJerochim/openapi-data/blob/master/0187_AspenwareUnity-UnityAPI-3.0-oas3-swagger.json}} expects the data to be in the request body.
Hybrid variants also exist. For instance, POST /edifact/validate\footnote{\url{https://github.com/AmitJerochim/openapi-data/blob/master/0604_EdiNation-edi-nation-api-2-swagger.json}} expects data in the request body and additional metadata in the URI.

Next, we assume that the response should be a truth-value, which is a resource in the meaning of REST in a broader sense. We mention in \ref{sec:bg_rest_and_http} that resources are abstract concepts and might have different representations. For example, we can use binary numbers to represent truth-values. Strings are also a suitable representation , e.g. "valid" and "invalid", "correct" and "not correct", or "true" and "false". JSON and XML fit as well, e.g., $\{ "valid:"true"\}$, $<valid>true</valid>$. We also might use HTTP status codes to represent truth-values., e.g., 200 for true and 400 for false. Finally, hybrid variants exist as well.

Indeed, we find several representatives for the examples above. For instance, POST /remittance/validate\footnote{\url{https://github.com/AmitJerochim/openapi-data/blob/master/oasFiles/2024_zheiro-ubx-i2i-api-portal-0.2.2-swagger.json}} might answer with $\{ "status:"failed"\}$, while POST /api/Order/validate\footnote{\url{https://github.com/AmitJerochim/openapi-data/blob/master/0187_AspenwareUnity-UnityAPI-3.0-oas3-swagger.json}} either respond with "true" or "false". The service operation POST /Order/validate\footnote{\url{https://github.com/AmitJerochim/openapi-data/blob/master/oasFiles/1708_Someorg1-au2web-v3-oas3-swagger.json}} uses JSON and XML and POST /admin/schema/validate\footnote{\url{https://github.com/AmitJerochim/openapi-data/blob/master/oasFiles/1384_osroot-yuuvis-1.0-swagger.json}}, or POST /x12/validate\footnote{\url{https://github.com/AmitJerochim/openapi-data/blob/master/0604_EdiNation-edi-nation-api-2-swagger.json}} use both HTTP status codes.

A matching unit, which considers any case, would match many wrong service operations. We design a matching unit that only matches service operation if they respond with a JSON object containing a boolean. We also present several service operations that use HTTP POST. However, we assume that validation should not change the server's state. Furthermore, we consider it is idempotent since multiple repeats of the validation process for a specific input should not return in different validation states. Therefore, the matching unit only matches service operations that use HTTP GET.