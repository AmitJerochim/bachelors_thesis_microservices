\section{Pattern-based Benchmarking Approach}
\label{sec:bg_pattern_based_approach}

There are several benchmarking approaches for systems that share a common interface (e.g., databases) \cite{RelWor:DB_NDBench, YCSB+T, BenchFoundary, RelWor:DB_COSBench, RelWork:OLTP, RelWork:CloudDBFramework, YCSB++, RelWor:VM_Borhani, RelWor:VM_Kejiang, RelWor:VM_Varghese, RelWor:VM_Zaitsev, RelWor:VM_Carpio}. A portable benchmarking tool does not exist for microservices yet, as their requests can vary broadly, and they do not share a common interface.

Martin  Grambow et al., however, argue that a benchmark should rely on the REST architectural style and present a pattern-based benchmarking approach and openISBT, a proof-of-concept prototype \cite{paper_grambow_benchmarking_microservices}. The second level of RMM supposes the use of HTTP methods and media types that describe service operations as well as possible. Martin Grambow et al. introduce the concept of abstract operations to design a portable benchmarking tool. The authors define abstract operations with a specific purpose. They argue that REST-based service operations with similar purposes also share the same HTTP methods and media types.  Therefore, openISBT should match specific service operations to these abstract operations. 

The authors present the five abstract operations CREATE, READ, SCAN, UPDATE, and DELETE that describe CRUD operations. SCAN and READ are both reading operations, which do not change the server's state and differ only in the resource scheme. SCAN describes service operations where the client receives a collection of resources, and READ describes services where the client receives a single resource.

As benchmarks should also be realistic, the workload is not defined on single abstract operations but on sequences of abstract operations called interaction patterns. The approach allows developers to configure custom interaction patterns. To provide an example, we assume an online-shop that offers different products.  A client might search for a product category and get a list of products. Then, it could pick a specific product from the list to get a detailed view. Therefore, it would first perform GET /products. Assuming the server would respond with a collection of products and one of them has the ID 1, the client could perform GET /products/1 to retrieve additional information about the product. We can define an abstract interaction pattern to describe this interaction. First, the client performs a SCAN, and then it performs a READ. 


The binding follows a three-step process. First, openISBT checks for each endpoint if it defines all operations to execute the interaction we define in the pattern. For the example above, it matches GET /products to SCAN and GET /products/{id} to READ. Assuming, the online-shop also allows retrieving a customers' list by performing GET /customers and creating a new customer by performing POST /customers. In this case, openISBT would match GET /customers to SCAN but could not match READ. Therefore, this endpoint is not supported, and openISBT cannot benchmark it with this interaction pattern. If openISBT can match all operations, it resolves dependencies between services. The operation GET /products/{id} defines a path parameter, and openISBT should replace it with a value that it receives after performing GET /products. Finally, openISBT ensures executability by checking if dependencies could be resolved. If executability is granted, openISBT generates a service-specific workload.

In our work, we focus on the first step and analyze each abstract operation isolated.